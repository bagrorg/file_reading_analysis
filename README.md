# Отчет
## Обозначения
На графиках `ms` означает микросекунды, `s` секунды, `b` байты и `mb` мегабайты.
## Характеристики

- OS: `Ubuntu 20.04.4 LTS`
- Linux Kernel: `5.13.0-39-generic`
- Processor: `Intel(R) Core(TM) i7-10700 CPU @ 2.90GHz`
- Memory device type: `SSD`
- File system: `ext4`
- I/O scheduler: `[mq-deadline] none`

## Различные батчи
Рассмотрим, как размер батча влияет на время нашей работы. Начнем анализ с рассмотрения зависимости времени от размера батча на фиксированном размере файла.

<p float="left">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20size%20%3D%201024.png" width="500" height="500">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20size%20%3D%2065536.png" width="500" height="500">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20size%20%3D%201048576.png" width="500" height="500">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20size%20%3D%2016777216.png" width="500" height="500">
</p>

Можно заметить, что в основном `ifstream` уступает `read` по производительности, кроме первой картинки. Однако на первом графике изображен довольно таки маленький размер файла, и, обратив внимание на ось `y` мы увидим, что разница неощутима.

Также видно, что, как и ожидалось, на больших размерах маленький размер батча может быть фатален для скорости работы. Действительно, слишком частое обращение к системному вызову начинает давать больший овердхед, чем использование более большого размера буффера.

Интересно, что на большинестве графиков оптимум не находится справа -- он где-то посередине между маленьким размером и размером самого файла. Это показывает, что использование этих функций может быть улучшено кусочным чтением. 



Теперь рассмотрим зависимость скорости работы от размера файла для разных размеров батчей

<p float="left">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20method%20%3D%20read.png" width="500" height="500">
  <img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/Batches%20experiment%2C%20method%20%3D%20ifstream.png" width="500" height="500">
</p>

Ожидаемо, размер батча на `128` показал себя значительно хуже остальных на больших данных. Эта тенденция была обсуждена выше. С ростом размера буффера работа в среднем становится лучше и на больших размерах сложно увидеть разницу, однако размер `131072` показал себя лучше, чем `2097152`. Будем использовать его для сравнения с `mmap`.


## Общее сравнение
Зафиксируем размеры батчей для `read` и `ifstream` и сравним их с `mmap`. Результаты можно видеть на следующих графиках:

<img src="https://github.com/bagrorg/file_reading_analysis/blob/development/report_process/full.png">

Наблюдая за маркерами на графиках видно, что `mmap` себя показывает чуть лучше, чем остальные, что делает его неплохим выбором для работы с файлами -- он быстр и не требует отдельной проработки с батчами.


Однако можно увидеть на графике интересное явление: примерно на `256` мегабайтах `mmap` и `ifstream` делают скачок по производительности в отрицательную сторону, в то время как `read` не реагирует никак. Возможно, это может быть объяснимо с аппаратной точки зрения.


Также стоит отметить, что такая маленькая разница, возможно, возникает из-за оверхеда, полученного от подсчета статистики байтов и использования различных служебных инструментов во время замеров. Для полноты картины мы можем посмотреть на результаты с немного другой стороны (см. след. параграф)


### Kernel time
Рассмотрим время работы в `kernel space`. Для этого используем утилиту `time`. 

| size      | method   | kernel_time, s |
|------------|----------|-------------|
| 128 b        | ifstream | 0.0         |
|            | mmap     | 0.0         |
|            | read     | 0.0         |
| 256 b       | ifstream | 0.005       |
|         | mmap     | 0.0         |
|         | read     | 0.0         |
| 512 b        | ifstream | 0.001       |
|         | mmap     | 0.0         |
|         | read     | 0.0         |
| 1 kb      | ifstream | 0.001       |
|        | mmap     | 0.0         |
|        | read     | 0.0         |
| 2 kb       | ifstream | 0.005       |
|        | mmap     | 0.002       |
|        | read     | 0.0         |
| 4 kb       | ifstream | 0.004       |
|        | mmap     | 0.0         |
|        | read     | 0.0         |
| 8 kb       | ifstream | 0.004       |
|        | mmap     | 0.0         |
|        | read     | 0.0         |
| 16 kb      | ifstream | 0.001       |
|       | mmap     | 0.0         |
|       | read     | 0.0         |
| 32 kb      | ifstream | 0.004       |
|       | mmap     | 0.001       |
|       | read     | 0.0         |
| 64 kb      | ifstream | 0.004       |
|       | mmap     | 0.0         |
|       | read     | 0.0         |
| 128 kb     | ifstream | 0.005       |
|      | mmap     | 0.0         |
|      | read     | 0.0         |
| 256 kb     | ifstream | 0.0         |
|      | mmap     | 0.0         |
|      | read     | 0.0         |
| 512 kb     | ifstream | 0.0         |
|      | mmap     | 0.0         |
|      | read     | 0.0         |
| 1 mb    | ifstream | 0.0         |
|     | mmap     | 0.0         |
|     | read     | 0.0         |
| 2 mb    | ifstream | 0.0         |
|     | mmap     | 0.0         |
|     | read     | 0.0         |
| 4 mb    | ifstream | 0.0         |
|     | mmap     | 0.004       |
|     | read     | 0.0         |
| 8 mb    | ifstream | 0.004       |
|     | mmap     | 0.0         |
|     | read     | 0.004       |
| 16 mb   | ifstream | 0.0         |
|    | mmap     | 0.004       |
|    | read     | 0.0         |
| 32 mb   | ifstream | 0.0         |
|    | mmap     | 0.004       |
|    | read     | 0.004       |
| 64 mb   | ifstream | 0.004       |
|    | mmap     | 0.0         |
|    | read     | 0.012       |
| 128 mb  | ifstream | 0.02        |
|   | mmap     | 0.012       |
|   | read     | 0.016       |
| 256 mb  | ifstream | 0.056       |
|   | mmap     | 0.012       |
|   | read     | 0.056       |
| 512 mb  | ifstream | 0.06        |
|   | mmap     | 0.048       |
|   | read     | 0.048       |
| 1 gb | ifstream | 0.084       |
|  | mmap     | 0.068       |
|  | read     | 0.121       |
| 2 gb | ifstream | 0.196       |
|  | mmap     | 0.088       |
|  | read     | 0.204       |


Как мы видим, мапинг файлов напрямую в память как правило проводит меньше времени в `kernel space`, хотя видно, что иногда конкуренты достигают похожих результатов (на маленьких размерах даже обгоняют).

Из данных можно также сделать вывод, что с ростом файла тенденция такая, что у `mmap` время в `kernel space` может расти медленнее, чем у остальных.

## Выводы
- При использовании `read`/`ifstream` может дать лучший перформанс подход с чтением по батчам
- Использование маленького размера батча на большом файле может обернуться в сильный проигрыш по перформансу
- `mmap` является хорошим (с точки зрения производительности) подходом для работы с файлами, однако вряд ли подойдет, если у нас ограниченный размер оперативной памяти
- `mmap` проводит меньше времени в `kernel space`
